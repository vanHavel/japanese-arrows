# Rules for the Japanese Arrows puzzle solver
# Each rule has a name, condition, complexity, and conclusions

- name: ARROW_POINTS_OOB
  condition: exists p (ahead(p) = 0)
  complexity: 1
  conclusions:
    - set(p, 0)
- name: ARROW_POINTS_IN_BOUNDS
  condition: exists p (ahead(p) > 0)
  complexity: 1
  conclusions:
    - exclude(p, 0)
- name: GRID_SIZE
  condition: exists p,i (ahead(p) = i)
  complexity: 1
  conclusions:
    - exclude(p, >i)
- name: DIRECTLY_SEEN
  condition: exists p,i (sees_distinct(p) = i)
  complexity: 1
  conclusions:
    - exclude(p, <i)
- name: SEEN_AND_FREE
  condition: exists p,i,j,k (sees_distinct(p) = i ^ ahead_free(p) = j ^ k = i + j)
  complexity: 2
  conclusions:
    - exclude(p, >k)
- name: NEXT_ARROW_SAME_DIRECTION
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(q) = i)
  complexity: 2
  conclusions:
    - only(p, [i, i+1])
- name: AHEAD_ARROW_SAME_DIRECTION
  condition: exists p,q,i (points_at(p, q) ^ dir(p) = dir(q) ^ val(q) = i)
  complexity: 2
  conclusions:
    - exclude(p, <i)
- name: PREVIOUS_ARROW_SAME_DIRECTION
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(p) = i)
  complexity: 2
  conclusions:
    - only(q, [i, i-1])
- name: PREVIOUS_ARROW_SAME_DIRECTION_VAL_SEEN
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(q) = i ^ exists r (points_at(q, r) ^ val(r) = i))
  complexity: 2
  conclusions:
    - set(p, i)
- name: BEFORE_ARROW_SAME_DIRECTION
  condition: exists p,q,i (points_at(p, q) ^ dir(p) = dir(q) ^ val(p) = i)
  complexity: 2
  conclusions:
    - exclude(q, >i)
- name: TRIPLE_ARROWS_SAME_DIRECTION
  condition: exists p,q,r,i (next(p) = q ^ next(q) = r ^ dir(p) = dir(q) ^ dir(q) = dir(r) ^ val(q) = i ^ val(r) = i)
  complexity: 2
  conclusions:
    - set(p, i)
- name: SEE_ALL_OPTIONS
  condition: exists p,q,i,j (val(p) = i ^ sees_distinct(p) = i ^ points_at(p, q) ^ candidate(q, j) ^ forall s (points_at(p, s) -> val(s) != j))
  complexity: 3
  conclusions:
    - exclude(q, j)
- name: FULL_SET_HIDDEN_SINGLE
  condition: exists p (val(p) = ahead(p) ^ sees_distinct_candidates(p) = ahead(p) ^ exists q,i (points_at(p, q) ^ candidate(q, i) ^ forall s (points_at(p, s) ^ s != q -> !candidate(s, i))))
  complexity: 3
  conclusions:
    - set(q, i)
- name: AHEAD_ARROW_SAME_DIRECTION_FREE
  condition: exists p,q,i,j,k,l (points_at(p, q) ^ dir(p) = dir(q) ^ val(q) = i ^ between_free(p, q) = j ^ sees_distinct(p) - sees_distinct(q) = k ^ l = i + j + k)
  complexity: 3
  conclusions:
    - exclude(p, >l)
- name: BEFORE_ARROW_SAME_DIRECTION_FREE
  condition: exists p,q,i,j,k,l (points_at(p, q) ^ dir(p) = dir(q) ^ val(p) = i ^ between_free(p, q) = j ^ sees_distinct(p) - sees_distinct(q) = k ^ l = i - j - k - 1)
  complexity: 3
  conclusions:
    - exclude(q, <l)