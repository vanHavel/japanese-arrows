# Rules for the Japanese Arrows puzzle solver
# Each rule has a name, condition, complexity, and conclusions

- name: ARROW_POINTS_OOB
  condition: exists p (ahead(p) = 0)
  kind: FO
  complexity: 1
  conclusions:
    - set(p, 0)
- name: ARROW_POINTS_IN_BOUNDS
  condition: exists p (ahead(p) > 0)
  kind: FO
  complexity: 1
  conclusions:
    - exclude(p, 0)
- name: GRID_SIZE
  condition: exists p,i (ahead(p) = i)
  kind: FO
  complexity: 1
  conclusions:
    - exclude(p, >i)
- name: DIRECTLY_SEEN
  condition: exists p,i (sees_distinct(p) = i)
  kind: FO
  complexity: 1
  conclusions:
    - exclude(p, <i)
- name: ONE
  condition: exists p,q,r,i (val(p) = 1 ^ points_at(p, q) ^ val(q) = nil ^ points_at(p, r) ^ val(r) = nil ^ q != r ^candidate(r, i) ^ !candidate(q, i))
  kind: FO
  complexity: 2
  conclusions:
    - exclude(r, i)
- name: SEEN_AND_FREE
  condition: exists p,i,j,k (sees_distinct(p) = i ^ ahead_free(p) = j ^ k = i + j)
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, >k)
- name: NEXT_ARROW_SAME_DIRECTION
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(q) = i)
  kind: FO
  complexity: 2
  conclusions:
    - only(p, [i, i+1])
- name: NEXT_ARROW_SAME_DIRECTION_VAL_SEEN
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(q) = i ^ exists r (points_at(q, r) ^ val(r) = i))
  kind: FO
  complexity: 2
  conclusions:
    - set(p, i)
- name: AHEAD_ARROW_SAME_DIRECTION
  condition: exists p,q,i (points_at(p, q) ^ dir(p) = dir(q) ^ val(q) = i)
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, <i)
- name: PREVIOUS_ARROW_SAME_DIRECTION
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(p) = i)
  kind: FO
  complexity: 2
  conclusions:
    - only(q, [i, i-1])
- name: PREVIOUS_ARROW_SAME_DIRECTION_VAL_AHEAD
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ val(p) = i ^ exists r (points_at(q, r) ^ val(r) = i-1))
  kind: FO
  complexity: 2
  conclusions:
    - set(q, i)
- name: BEFORE_ARROW_SAME_DIRECTION
  condition: exists p,q,i (points_at(p, q) ^ dir(p) = dir(q) ^ val(p) = i)
  kind: FO
  complexity: 2
  conclusions:
    - exclude(q, >i)
- name: TRIPLE_ARROWS_SAME_DIRECTION
  condition: exists p,q,r,i (next(p) = q ^ next(q) = r ^ dir(p) = dir(q) ^ dir(q) = dir(r) ^ val(q) = i ^ val(r) = i)
  kind: FO
  complexity: 2
  conclusions:
    - set(p, i)
- name: UNIQUE_COMMON_CANDIDATE_1
  condition: exists p,q,i (val(p) = 1 ^ points_at(p, q) ^ (forall s (points_at(p, s) -> candidate(s, i))) ^ (forall j ((forall t (points_at(p, t) -> candidate(t, j))) -> i = j)))
  kind: FO
  complexity: 2
  conclusions:
    - set(q, i)
- name: MAX_CANDIDATES
  condition: exists p,i (sees_distinct_candidates(p) = i ^ max_candidate(p) > i)
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, >i)
- name: NEXT_ARROW_SAME_DIRECTION_MINCANDIDATE
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ min_candidate(q) = i)
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, <i)
- name: NEXT_ARROW_SAME_DIRECTION_MAXCANDIDATE
  condition: exists p,q,i (next(p) = q ^ dir(p) = dir(q) ^ max_candidate(q) = i)
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, >i+1)
- name: SEEN_AND_NEW
  condition: exists p,q,i (points_at(p, q) ^ sees_distinct(p) = i ^ forall j (candidate(q, j) -> !sees_value(p, j)))
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, i)
- name: ALL_DISTINCT
  condition: exists p,q,r,i (sees_distinct(p) + ahead_free(p) = val(p) ^ points_at(p, q) ^ points_at(p, r) ^ q != r ^ val(q) = i ^ val(r) = nil)
  kind: FO
  complexity: 3
  conclusions:
    - exclude(r, i)
- name: SEE_ALL_OPTIONS
  condition: exists p,q,i,j (val(p) = i ^ sees_distinct(p) = i ^ points_at(p, q) ^ candidate(q, j) ^ forall s (points_at(p, s) -> val(s) != j))
  kind: FO
  complexity: 3
  conclusions:
    - exclude(q, j)
- name: FULL_SET_HIDDEN_SINGLE
  condition: exists p (val(p) = ahead(p) ^ sees_distinct_candidates(p) = ahead(p) ^ exists q,i (points_at(p, q) ^ candidate(q, i) ^ forall s (points_at(p, s) ^ s != q -> !candidate(s, i))))
  kind: FO
  complexity: 3
  conclusions:
    - set(q, i)
- name: AHEAD_ARROW_SAME_DIRECTION_FREE
  condition: exists p,q,i,j,k,l (points_at(p, q) ^ dir(p) = dir(q) ^ val(q) = i ^ between_free(p, q) = j ^ sees_distinct(p) - sees_distinct(q) = k ^ l = i + j + k)
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, >l)
- name: BEFORE_ARROW_SAME_DIRECTION_FREE
  condition: exists p,q,i,j,k,l (points_at(p, q) ^ dir(p) = dir(q) ^ val(p) = i ^ between_free(p, q) = j ^ sees_distinct(p) - sees_distinct(q) = k ^ l = i - j - k - 1)
  kind: FO
  complexity: 3
  conclusions:
    - exclude(q, <l)
- name: MAX_VAL_AT_EDGES_CONFIRM
  condition: exists p,q,i (behind(p) = 0 ^ behind(q) = 0 ^ points_at(p, q) ^ points_at(q, p) ^ val(p) = ahead(p) ^ val(p) = i)
  kind: FO
  complexity: 3
  conclusions:
    - set(q, i)
- name: MAX_VAL_AT_EDGES_DENY
  condition: exists p,q,i (behind(p) = 0 ^ behind(q) = 0 ^ points_at(p, q) ^ points_at(q, p) ^ i = ahead(p) ^ !candidate(p, i))
  kind: FO
  complexity: 3
  conclusions:
    - exclude(q, i)
- name: OPPOSITES_LOWER_BOUND
  condition: exists p,q,i,j,k (points_at(p, q) ^ points_at(q, p) ^ val(q) = i ^ behind(p) = j ^ k = i - j - 1)
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, <k)
- name: OPPOSITES_LOWER_BOUND_CANDIDATES
  condition: exists p,q,i,j,k (points_at(p, q) ^ points_at(q, p) ^ min_candidate(q) = i ^ behind(p) = j ^ k = i - j - 1)
  kind: FO
  complexity: 4
  conclusions:
    - exclude(p, <k)
- name: BACKTRACK_SIMPLE
  kind: Backtrack
  complexity: 5
  backtrack_depth: 1
  rule_depth: 2
  max_rule_complexity: 3
- name: BACKTRACK_COMPLEX
  kind: Backtrack
  complexity: 6
  backtrack_depth: 1
  rule_depth: 15
  max_rule_complexity: 4