# Rules for the Japanese Arrows puzzle solver
# Each rule has a name, condition, complexity, and conclusions

- name: ARROW_POINTS_OOB
  condition: exists p (ahead(p) = 0)
  kind: FO
  complexity: 1
  conclusions:
    - set(p, 0)
- name: ARROW_POINTS_IN_BOUNDS
  condition: exists p (ahead(p) > 0)
  kind: FO
  complexity: 1
  conclusions:
    - exclude(p, 0)
- name: GRID_SIZE
  condition: exists p (val(p) = nil)
  kind: FO
  complexity: 1
  conclusions:
    - exclude(p, > ahead(p))
- name: DIRECTLY_SEEN
  condition: exists p (val(p) = nil)
  kind: FO
  complexity: 1
  conclusions:
    - exclude(p, < sees_distinct(p))
- name: SEEN_AND_FREE
  condition: |
    exists p,i (
      val(p) = nil ^
      i = sees_distinct(p) + ahead_free(p)
    )
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, >i)
- name: NEXT_ARROW_SAME_DIRECTION
  condition: |
    exists q,p (
      val(q) != nil ^
      next(p) = q ^
      dir(p) = dir(q)
    )
  kind: FO
  complexity: 2
  conclusions:
    - only(p, [val(q), val(q)+1])
- name: NEXT_ARROW_SAME_DIRECTION_VAL_SEEN
  condition: |
    exists q,p (
      val(p) = nil ^
      val(q) != nil ^
      next(p) = q ^
      candidate(p, val(q)) ^
      dir(p) = dir(q) ^
      exists r (points_at(q, r) ^ val(r) = val(q))
    )
  kind: FO
  complexity: 2
  conclusions:
    - set(p, val(q))
- name: AHEAD_ARROW_SAME_DIRECTION
  condition: |
    exists q,p (
      val(q) != nil ^
      points_at(p, q) ^
      dir(p) = dir(q)
    )
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, < val(q))
- name: PREVIOUS_ARROW_SAME_DIRECTION
  condition: |
    exists p,q (
      val(p) != nil ^
      next(p) = q ^
      dir(p) = dir(q)
    )
  kind: FO
  complexity: 2
  conclusions:
    - only(q, [val(p), val(p)-1])
- name: PREVIOUS_ARROW_SAME_DIRECTION_VAL_AHEAD
  condition: |
    exists p,q (
      val(p) != nil ^
      next(p) = q ^
      val(q) = nil ^
      dir(p) = dir(q) ^
      exists r (points_at(q, r) ^ val(r) = val(p)-1)
    )
  kind: FO
  complexity: 2
  conclusions:
    - set(q, val(p))
- name: BEFORE_ARROW_SAME_DIRECTION
  condition: |
    exists p,q (
      val(p) != nil ^
      points_at(p, q) ^
      dir(p) = dir(q)
    )
  kind: FO
  complexity: 2
  conclusions:
    - exclude(q, > val(p))
- name: TRIPLE_ARROWS_SAME_DIRECTION
  condition: |
    exists p,q,r (
      val(p) = nil ^
      next(p) = q ^
      dir(p) = dir(q) ^
      val(q) != nil ^
      next(q) = r ^
      dir(q) = dir(r) ^
      val(r) = val(q) 
    )
  kind: FO
  complexity: 2
  conclusions:
    - set(p, val(r))
- name: UNIQUE_COMMON_CANDIDATE_1
  condition: |
    exists p,q,i (
      val(p) = 1 ^
      points_at(p, q) ^
      (forall s (points_at(p, s) -> candidate(s, i))) ^
      (forall j ((forall t (points_at(p, t) -> candidate(t, j))) -> i = j))
    )
  kind: FO
  complexity: 2
  conclusions:
    - set(q, i)
- name: MAX_CANDIDATES
  condition: exists p (max_candidate(p) > sees_distinct_candidates(p))
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, > sees_distinct_candidates(p))
- name: ELIMINATE_1
  condition: |
    exists p (
      candidate(p, 1) ^
      forall i (exists q (points_at(p, q) ^ !candidate(q, i)))
    )
  kind: FO
  complexity: 2
  conclusions:
    - exclude(p, 1)
- name: NEXT_ARROW_SAME_DIRECTION_MINCANDIDATE
  condition: |
    exists p,q (
      next(p) = q ^
      dir(p) = dir(q)
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, < min_candidate(q))
- name: NEXT_ARROW_SAME_DIRECTION_MAXCANDIDATE
  condition: |
    exists p,q (
      next(p) = q ^
      dir(p) = dir(q)
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, > max_candidate(q) + 1)
- name: SEEN_AND_NEW
  condition: |
    exists p,q,i (
      points_at(p, q) ^
      forall j (candidate(q, j) -> !sees_value(p, j))
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, sees_distinct(p))
- name: ALL_DISTINCT
  condition: |
    exists p,i,r (
      sees_distinct(p) + ahead_free(p) = val(p) ^
      sees_value(p, i) ^
      points_at(p, r) ^
      val(r) = nil
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(r, i)
- name: SEE_ALL_OPTIONS
  condition: |
    exists p,q,j (
      val(p) = sees_distinct(p) ^
      points_at(p, q) ^
      candidate(q, j) ^
      forall s (points_at(p, s) -> val(s) != j)
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(q, j)
- name: FULL_SET_HIDDEN_SINGLE
  condition: |
    exists p (
      val(p) = sees_distinct_candidates(p) ^
      exists q,i (
        points_at(p, q) ^
        candidate(q, i) ^
        forall s (points_at(p, s) ^ s != q -> !candidate(s, i))
      )
    )
  kind: FO
  complexity: 3
  conclusions:
    - set(q, i)
- name: AHEAD_ARROW_SAME_DIRECTION_FREE
  condition: |
    exists p,q,i (
      points_at(p, q) ^
      dir(p) = dir(q) ^
      val(q) != nil ^
      i = val(q) + between_free(p, q) + sees_distinct(p) - sees_distinct(q) ^
      max_candidate(p) > i
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, >i)
- name: BEFORE_ARROW_SAME_DIRECTION_FREE
  condition: |
    exists p,q,i (
      points_at(p, q) ^
      dir(p) = dir(q) ^
      i = val(p) - between_free(p, q) - sees_distinct(p) + sees_distinct(q) - 1 ^
      min_candidate(q) < i
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(q, <i)
- name: MAX_VAL_AT_EDGES_CONFIRM
  condition: |
    exists p,q (
      behind(p) = 0 ^
      behind(q) = 0 ^
      points_at(p, q) ^
      points_at(q, p) ^
      val(p) = ahead(p)
    )
  kind: FO
  complexity: 3
  conclusions:
    - set(q, val(p))
- name: MAX_VAL_AT_EDGES_DENY
  condition: |
    exists p,q (
      behind(p) = 0 ^
      behind(q) = 0 ^
      points_at(p, q) ^
      points_at(q, p) ^
      !candidate(p, ahead(p))
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(q, ahead(p))
- name: OPPOSITES_LOWER_BOUND
  condition: |
    exists p,q,i (
      points_at(p, q) ^
      points_at(q, p) ^
      i = val(q) - behind(p) - 1 ^
      min_candidate(p) < i  
    )
  kind: FO
  complexity: 3
  conclusions:
    - exclude(p, <i)
- name: FREE_AHEAD_DISTINCT
  condition: |
    exists p,i (
      val(p) = nil ^
      i = ahead_free(p) + sees_distinct(p) ^
      forall s,k (
        (points_at(p, s) ^ val(s) = nil ^ candidate(s, k)) -> !sees_value(p, k)
      ) ^
      forall q,r (
        (points_at(p, q) ^ val(q) = nil ^ points_at(q, r) ^ val(r) = nil) ->
        forall i (
          (candidate(q, i) -> !candidate(r, i)) ^
          (candidate(r, i) -> !candidate(q, i))
        )
      )
    )
  kind: FO
  complexity: 4
  conclusions:
    - set(p, i)
- name: OPPOSITES_LOWER_BOUND_CANDIDATES
  condition: |
    exists p,q,i (
      points_at(p, q) ^
      points_at(q, p) ^
      i = min_candidate(q) - behind(p) - 1
    )
  kind: FO
  complexity: 4
  conclusions:
    - exclude(p, <i)
- name: BACKTRACK_SIMPLE
  kind: Backtrack
  complexity: 5
  backtrack_depth: 1
  rule_depth: 1
  max_rule_complexity: 3
- name: BACKTRACK_COMPLEX
  kind: Backtrack
  complexity: 6
  backtrack_depth: 1
  rule_depth: 2
  max_rule_complexity: 4
- name: BACKTRACK_ULTRA
  kind: Backtrack
  complexity: 7
  backtrack_depth: 1
  rule_depth: 3
  max_rule_complexity: 4